#' Dose-Response Curves
#'
#' Given a SummarizedExperiment object created by \code{\link{GRfit}},
#' this function plots either the growth-rate inhibition (GR) dose response 
#' curves or the traditional dose response curves for a given set of data.
#'
#' @param fitData an element of class SummarizedExperiment, generated by the 
#' GRfit function.
#' @param metric either "GR" for GR dose response curves or "rel_cell" for 
#' traditional dose response curves based on relative cell count.
#' @param experiments the names of the experiments to plot (or "all")
#' @param min the minimum concentration to plot (for curves)
#' @param max the maximum concentration to plot (for curves)
#' @param points a logical value indicating whether points (individual GR
#' values) will be plotted
#' @param curves a logical value indicating whether sigmoidal dose-response
#' curves will be plotted
#' @param theme a ggplot or ggsci theme.
#' @param plotly a logical value indicating whether to output a ggplot2 graph
#' or a ggplotly graph
#'
#' @return ggplot2 or ggplotly graphs of Growth-rate inhibition dose-response
#' curves
#' @author Nicholas Clark
#' @details
#' Given a SummarizedExperiment object created by \code{\link{GRfit}},
#' this function plots these GR values (versus concentration) and/or the
#' sigmoidal curves fitted to the sets of points. The results can be viewed
#' in a static ggplot image or an interactive plotly graph.
#'
#' The "min" and "max" parameters control the concentration values for which
#' the curves are plotted. They are automatically set to the minimum and
#' maximum concentrations of the data, but can be set by the user as well.
#' "min" and "max" take raw values (not log transformed) for concentration.
#'
#' By default, curves and points are plotted for all experiments. To specify
#' a smaller set of experiments, use the "experiments" parameter. To see the
#' names of individual experiments for a GRfit object \code{fit_example}, see
#' \code{colData(fit_example)}. See the examples below.
#' @seealso To create the object needed for this function, see
#' \code{\link{GRfit}}. For other visualizations, see \code{\link{GRbox}} and
#' \code{\link{GRscatter}}. For online GR calculator and browser, see
#' \url{http://www.grcalculator.org}.
#' @examples
#' # Load Case A (example 1) input
#' data("inputCaseA")
#' # Run GRfit function with case = "A"
#' drc_output = GRfit(inputCaseA,
#' groupingVariables = c('cell_line','agent'))
#' GRdrawDRC(drc_output, experiments = c('BT20 drugA', 'MCF10A drugA',
#' 'MCF7 drugA'), min = 10^(-4), max = 10^2)
#' GRdrawDRC(drc_output, plotly = FALSE)
#' @export


#### todo:
# - add checks for additional inputs
# - edit example and vignette to reflect new inputs
# - add se option for error bars
# - finish up palette and theme options
# - add a message or error output noting updated function inputs
# - figure out adding a geom to plotly (for log-ticks and scientific notation) or 
#   how to make log-ticks from geom_segment only (should work with plotly) ( long-term )
# - clean up "GRfit" object processing (with dplyr)
# - fix for rel_cell curve and limit code duplication
GRdrawDRC <- function(fitData, metric = c("GR", "rel_cell"), experiments = "all",
                      min = "auto", max = "auto",
                      points = c("average", "all", "none"),
                      curves = c("fit", "line", "none"),
                      bars = c("none", "sd", "se"),
                      xrug = c("none", "GR50", "GEC50", "IC50", "EC50"),
                      yrug = c("none", "GRinf", "GRmax", "Einf", "Emax"),
                      theme = c("classic", "minimal", "bw"),
                      palette = c("default","npg", "aaas"),
                      facet_row = "none",
                      facet_col = "none",
                      plot_type = c("static", "interactive")) {
  
  # make all inputs length 1
  metric = metric[1]
  points = points[1]
  curves = curves[1]
  bars = bars[1]
  xrug = xrug[1]
  yrug = yrug[1]
  theme = theme[1]
  palette = palette[1]
  # get grouping variables
  group_vars = GRgetGroupVars(fitData)
  # assertthat::assert_that(palette %in% c("default","npg", "aaas"), 
  #                         msg = "palette must be one of the following: 'default', 'npg', 'aaas'")
  # check that metric is allowed
  assertthat::assert_that(is.character(metric))
  assertthat::assert_that(metric %in% c("GR", "rel_cell"))
  # check that xrug and yrug are allowed
  xrug_options = c("none", "GR50", "GEC50", "IC50", "EC50")
  assertthat::assert_that(is.character(xrug))
  assertthat::assert_that(xrug %in% xrug_options, 
    msg = 'xrug must be one of the following: "none", "GR50", "GEC50", "IC50", "EC50"')
  
  yrug_options = c("none", "GRinf", "GRmax", "Einf", "Emax")
  assertthat::assert_that(is.character(yrug))
  assertthat::assert_that(yrug %in% yrug_options, 
    msg = 'yrug must be one of the following: "none", "GRinf", "GRmax", "Einf", "Emax"')
  # check to make sure the rug matches the metric... e.g. GR50 rug only for "GR" curve
  # xrug
  assertthat::assert_that(!(metric == "GR" && xrug %in% c("IC50", "EC50")),
                          msg = 'For metric "GR", xrug must be "GR50" or GEC50"')
  assertthat::assert_that(!(metric == "rel_cell" && xrug %in% c("GR50", "GEC50")),
                          msg = 'For metric "rel_cell", xrug must be "IC50" or "EC50"')
  # yrug
  assertthat::assert_that(!(metric == "GR" && yrug %in% c("Einf", "Emax")),
                          msg = 'For metric "GR", yrug must be "GRinf" or "GRmax"')
  assertthat::assert_that(!(metric == "rel_cell" && yrug %in% c("GRinf", "GRmax")),
                          msg = 'For metric "rel_cell", yrug must be "Einf" or "Emax"')
  # check that facets are allowed
  assertthat::assert_that(facet_row %in% c("none", group_vars))
  assertthat::assert_that(facet_col %in% c("none", group_vars))
  assertthat::assert_that(facet_col != facet_row | (facet_col == "none" && facet_row == "none"),
                          msg = "facet_col and facet_row must be different")
  if(metric == "IC") {
    message('For the traditional dose-response curve based on relative cell counts, 
            please use metric = "rel_cell" instead of metric = "IC". This notation 
            has been changed as of Version 1.3.2.')
  }
  
  # declaring values NULL to avoid note on package check
  log10_concentration = NULL
  experiment = NULL
  data = S4Vectors::metadata(fitData)[[1]]
  parameterTable = cbind(as.data.frame(SummarizedExperiment::colData(fitData)),
                        t(SummarizedExperiment::assay(fitData)))
  groupingVariables = S4Vectors::metadata(fitData)[[2]]
  data$log10_concentration = log10(data$concentration)
  tmp<-data[,groupingVariables, drop = FALSE]
  experimentNew = (apply(tmp,1, function(x) (paste(x,collapse=" "))))
  if(length(groupingVariables) > 0) {
    data$experiment = as.factor(experimentNew)
  } else {
    data$experiment = as.factor("All Data")
  }
  if(!identical(experiments, "all")) {
    parameterTable = parameterTable[parameterTable$experiment %in%
                                      experiments, ]
    data = data[data$experiment %in% experiments, ]
  }
  if(min == "auto") min = min(data$concentration, na.rm = TRUE)
  if(max == "auto") max = max(data$concentration, na.rm = TRUE)
  # define x support for curve
  len = (log10(max) - log10(min))*100
  concentration = 10^(seq(log10(min) - 1, log10(max) + 1,
                          length.out = len))
  # filter table of fit parameters to only selected experiments
  parameterTable %<>% filter(experiment %in% exps) %>% as_tibble()
  # define function for curve mapping
  .create_curve_data = function(EC50, Einf, h, fit_type, flat_fit, experiment, c) {
    df = data.frame(experiment = experiment, concentration = c, log10_concentration = log10(c))
    if(fit_type == "sigmoid") df$y_val = Einf + (1 - Einf)/(1 + (c/EC50)^h)
    if(fit_type == "flat") df$y_val = flat_fit
    #if(fit_type == "biphasic") df$y_val = NA ### make df for biphasic fit
    return(df)
  }
  # make list (tibble) of inputs for curve
  if(metric == "rel_cell") {
    curve_input_list = parameterTable %>% dplyr::select(EC50, Einf, h, fit_rel_cell, flat_fit_rel_cell, experiment) %>%
      dplyr::rename(fit_type = fit_rel_cell, flat_fit = flat_fit_rel_cell) %>% dplyr::as_tibble() %>%
      dplyr::mutate(c = list(concentration))
  } else if(metric == "GR") {
    curve_input_list = parameterTable %>% dplyr::select(GEC50, GRinf, h_GR, fit_GR, flat_fit_GR, experiment) %>%
      dplyr::rename(EC50 = GEC50, Einf = GRinf, h = h_GR, fit_type = fit_GR, flat_fit = flat_GR) %>% 
      dplyr::as_tibble() %>% dplyr::mutate(c = list(concentration))
  }
  # Get data frames for curves to give to ggplot
  curve_data_all = pmap_dfr(.l = curve_input_list, .f = .create_curve_data)

  # len = (log10(max) - log10(min))*100
  # Concentration = 10^(seq(log10(min) - 1, log10(max) + 1,
  #                         length.out = len))
  # curve_data_all = NULL
  # exps = unique(parameterTable$experiment)
  # for(exp in exps) {
  #   row = which(parameterTable$experiment == exp)
  #   if(metric == "GR") {
  #     GEC50 = parameterTable$GEC50[row]
  #     GRinf = parameterTable$GRinf[row]
  #     h_GR = parameterTable$h_GR[row]
  #     logistic_3u = function(c){GRinf + (1 - GRinf)/(1 + (c/GEC50)^h_GR)}
  #   } else if (metric %in% c("rel_cell", "IC")) {
  #     EC50 = parameterTable$EC50[row]
  #     Einf = parameterTable$Einf[row]
  #     h = parameterTable$h[row]
  #     logistic_3u = function(c){Einf + (1 - Einf)/(1 + (c/EC50)^h)}
  #   }
  #   curve_data = as.matrix(concentration)
  #   colnames(curve_data) = "Concentration"
  #   if(metric == "GR") {
  #     if(parameterTable$fit_GR[row] == "sigmoid") {
  #       GR = apply(curve_data, 1, logistic_3u)
  #     } else {
  #       GR = parameterTable$flat_fit_GR[row]
  #     }
  #     curve_data = cbind(curve_data, GR)
  #   } else if(metric %in% c("rel_cell", "IC")) {
  #     if(parameterTable$fit_rel_cell[row] == "sigmoid") {
  #       rel_cell_count = apply(curve_data, 1, logistic_3u)
  #     } else {
  #       rel_cell_count = parameterTable$flat_fit_rel_cell[row]
  #     }
  #     curve_data = cbind(curve_data, rel_cell_count)
  #   }
  #   curve_data = as.data.frame(curve_data)
  #   curve_data$experiment = exp
  #   if(is.null(curve_data_all)){
  #     curve_data_all = curve_data
  #   } else {
  #     curve_data_all = rbind(curve_data_all, curve_data)
  #   }
  # }
  # curve_data_all = merge(curve_data_all, parameterTable[, c(groupingVariables, "experiment")])
  # curve_data_all$experiment = as.factor(curve_data_all$experiment)

  data$GRvalue = signif(data$GRvalue, 3)
  data$log10_concentration = signif(data$log10_concentration, 3)
  #data_mean = data %>% group_by(experiment, log10_concentration, concentration) %>% 
  data_mean = data %>% dplyr::group_by_at(c(group_vars, "experiment", 
                  "concentration", "log10_concentration")) %>%
    dplyr::summarise(GRvalue_mean = mean(GRvalue, na.rm = TRUE), 
                     GRvalue_sd = sd(GRvalue, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(experiment = as.character(experiment))
  ####### testing
  #data$GRvalue_mean = 
  #######
  data_mean %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3))
  parameterTable %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3))
  curve_data_all %<>% dplyr::mutate(log10_concentration = log10(concentration)) %>%
    dplyr::mutate_if(is.numeric, function(x) signif(x,3))
  # initialize plot
  p = ggplot2::ggplot()
  if(metric == "GR") {
    # add curves to the plot
    if(curves == "line") {
      p = p + ggplot2::geom_line(data = data_mean, ggplot2::aes(x = log10_concentration,
            y = GRvalue_mean, colour = experiment), size = 1.1)
            #### scale transformations don't work with plotly :(
            # scale_x_continuous(
            #               labels = trans_format("identity", math_format(10^.x)),
            #               limits = c(-3.5, 1.5)
            #) + annotation_logticks(sides = "b", short = unit(0.1, "cm"), mid = unit(0.2, "cm"),
            #             long = unit(0.3, "cm"))
            # ggplot2::geom_errorbar(data = data_mean, ggplot2::aes(x = log10_concentration,ymin = GRvalue_mean - GRvalue_sd,
            #   ymax = GRvalue_mean + GRvalue_sd, colour = experiment), width = 0.5)
    } else if(curves == "fit") {
      p = p + ggplot2::geom_line(data = curve_data_all,
            ggplot2::aes(x = log10_concentration, y = GR, colour = experiment), size = 1.1)
    } else if(curves == "none") {
      # do nothing
    }
    # add points to the plot
    if(points == "average") {
      p = p + ggplot2::geom_point(data = data_mean, ggplot2::aes(x = log10_concentration,
        y = GRvalue_mean, colour = experiment), size = 2)
    } else if(points == "all") {
      p = p + ggplot2::geom_point(data = data, ggplot2::aes(x = log10_concentration,
            y = GRvalue, colour = experiment), size = 2)
    } else if(points == "none") {
      # do nothing
    }
    # set x and y range for plot, set labels, add horizontal lines
    p = p + ggplot2::coord_cartesian(xlim = c(log10(min)-0.1,
                                              log10(max)+0.1),
                                     ylim = c(-1, 1.5), expand = F) +
      ggplot2::ggtitle("Concentration vs. GR values") +
      ggplot2::xlab('Concentration (log10 scale)') +
      ggplot2::ylab('GR value') +
      #ggplot2::geom_hline(yintercept = 1, size = 1, linetype = "dashed") +
      #ggplot2::geom_hline(yintercept = 0.5, size = 1, linetype = "dashed") +
      #ggplot2::geom_hline(yintercept = -1, size = 1, linetype = "dashed")
      ggplot2::geom_hline(yintercept = 0, size = 1, colour = "#1F77B4")
  } else if(metric %in% c("rel_cell", "IC")) {
    if(points == TRUE & curves == FALSE) {
      p = ggplot2::ggplot(data = data, ggplot2::aes(x = log10_concentration,
          y = rel_cell_count, colour = experiment)) + ggplot2::geom_point()
    } else if(points == FALSE & curves == TRUE) {
      p = ggplot2::ggplot(data = curve_data_all,
                          ggplot2::aes(x = log10(concentration),
          y = rel_cell_count, colour = experiment)) + ggplot2::geom_line()
    } else if(points == TRUE & curves == TRUE) {
      p = ggplot2::ggplot() + ggplot2::geom_line(data = curve_data_all,
        ggplot2::aes(x = log10_concentration, y = rel_cell_count,
                     colour = experiment)) +
        ggplot2::geom_point(data = data, ggplot2::aes(x = log10_concentration,
                            y = rel_cell_count, colour = experiment))
    }
    p = p + ggplot2::coord_cartesian(xlim = c(log10(min)-0.1,
                                              log10(max)+0.1),
                                     ylim = c(0, 1.5), expand = TRUE) +
      ggplot2::ggtitle("Concentration vs. Relative cell count") +
      ggplot2::xlab('Concentration (log10 scale)') +
      ggplot2::ylab('Relative cell count') + ggplot2::labs(colour = "") +
      ggplot2::geom_hline(yintercept = 1, size = .25) +
      ggplot2::geom_hline(yintercept = 0.5, size = .25) +
      ggplot2::geom_hline(yintercept = 0, size = .25)
  }
  ### Change code above so that curve parameters are called the same thing
  ### for GR and traditional curve. Then change rug names below to agree with this.
  ### Maybe make an option for marginal plots of GR metrics instead of rugs.
  ### Check how to change color scheme so that colors get used more than once
  ### instead of running out of colors
  
  # add rugs to plot
  rug_size = 1.1
  if(xrug != "none") p = p + ggplot2::geom_rug(data = parameterTable,
    ggplot2::aes_string(x = paste0("log10_", xrug), colour = "experiment"), size = rug_size)
  if(yrug != "none") p = p + ggplot2::geom_rug(data = parameterTable,
    ggplot2::aes_string(y = yrug, colour = "experiment"), size = rug_size)
  ### alternative way to do the rug... allows for length control (good), but xrug and yrug 
  ### can look like different lengths on the screen (bad)
  # rug_len = 0.25
  # if(xrug != "none") {
  #   p = p + ggplot2::geom_segment(data = parameterTable, 
  #     ggplot2::aes_string(x = paste0("log10_", xrug), xend = paste0("log10_", xrug),
  #                         y = p$coordinates$limits$y[1], yend = p$coordinates$limits$y[1] + rug_len,
  #                         colour = "experiment"), size = rug_size)
  # }
  # if(yrug != "none") {
  #   p = p + ggplot2::geom_segment(data = parameterTable, 
  #     ggplot2::aes_string(x = p$coordinates$limits$x[1], xend = p$coordinates$limits$x[1] + rug_len,
  #                         y = yrug, yend = yrug,
  #                         colour = "experiment"), size = rug_size)
  # }
  # add theme to plot
  p = p + ggplot2::theme_classic() #+ do.call(theme, args = list())
  # add palette to plot
  ###p = p + scale_colour_npg()
  # configure plot facets
  if(facet_row != "none" | facet_col != "none") {
    if(facet_row == "none") facet_row = "."
    if(facet_col == "none") facet_col = "."
    p = p + ggplot2::facet_grid(stats::reformulate(facet_col,facet_row))
  }
  # return ggplot or plotly object
  if(plot_type == "interactive") {
    if(facet_row != ".") {
      # give extra x-axis space so that the legend doesn't overlap labels
      q = plotly::ggplotly(p) %>% plotly::layout(legend = list(x = 1.05))
    } else {
      q = plotly::ggplotly(p)
    }
    return(q)
  } else {
    return(p)
  }
}
