#' Dose-Response Curves
#'
#' Given a SummarizedExperiment object created by \code{\link{GRfit}},
#' this function plots either the growth-rate inhibition (GR) dose response 
#' curves or the traditional dose response curves for a given set of data.
#'
#' @param fitData an element of class SummarizedExperiment, generated by the 
#' GRfit function.
#' @param metric either "GR" for GR dose response curves or "rel_cell" for 
#' traditional dose response curves based on relative cell count.
#' @param experiments the names of the experiments to plot (or "all")
#' @param min the minimum concentration to plot (for curves)
#' @param max the maximum concentration to plot (for curves)
#' @param points a logical value indicating whether points (individual GR
#' values) will be plotted
#' @param curves a logical value indicating whether sigmoidal dose-response
#' curves will be plotted
#' @param theme a ggplot or ggsci theme.
#' @param plotly a logical value indicating whether to output a ggplot2 graph
#' or a ggplotly graph
#'
#' @return ggplot2 or ggplotly graphs of Growth-rate inhibition dose-response
#' curves
#' @author Nicholas Clark
#' @details
#' Given a SummarizedExperiment object created by \code{\link{GRfit}},
#' this function plots these GR values (versus concentration) and/or the
#' sigmoidal curves fitted to the sets of points. The results can be viewed
#' in a static ggplot image or an interactive plotly graph.
#'
#' The "min" and "max" parameters control the concentration values for which
#' the curves are plotted. They are automatically set to the minimum and
#' maximum concentrations of the data, but can be set by the user as well.
#' "min" and "max" take raw values (not log transformed) for concentration.
#'
#' By default, curves and points are plotted for all experiments. To specify
#' a smaller set of experiments, use the "experiments" parameter. To see the
#' names of individual experiments for a GRfit object \code{fit_example}, see
#' \code{colData(fit_example)}. See the examples below.
#' @seealso To create the object needed for this function, see
#' \code{\link{GRfit}}. For other visualizations, see \code{\link{GRbox}} and
#' \code{\link{GRscatter}}. For online GR calculator and browser, see
#' \url{http://www.grcalculator.org}.
#' @examples
#' # Load Case A (example 1) input
#' data("inputCaseA")
#' # Run GRfit function with case = "A"
#' drc_output = GRfit(inputCaseA,
#' groupingVariables = c('cell_line','agent'))
#' GRdrawDRC(drc_output, experiments = c('BT20 drugA', 'MCF10A drugA',
#' 'MCF7 drugA'), min = 10^(-4), max = 10^2)
#' GRdrawDRC(drc_output)
#' @export


#### todo:
# - add checks for additional inputs
# - edit example and vignette to reflect new inputs
# - finish up palette and theme options
# - add a message or error output noting updated function inputs
# - figure out adding a geom to plotly (for log-ticks and scientific notation) or 
#   how to make log-ticks from geom_segment only (should work with plotly) ( long-term )
GRdrawDRC <- function(fitData, metric = c("GR", "rel_cell"), experiments = "all",
                      min = "auto", max = "auto",
                      points = c("average", "all", "none"),
                      curves = c("fit", "line", "none"),
                      bars = c("none", "sd", "se"),
                      xrug = c("none", "GR50", "GEC50", "IC50", "EC50"),
                      yrug = c("none", "GRinf", "GRmax", "Einf", "Emax"),
                      theme = c("classic", "minimal", "bw"),
                      palette = c("default","npg", "aaas"),
                      facet_row = "none",
                      facet_col = "none",
                      plot_type = c("static", "interactive")) {
  
  # make all inputs length 1
  metric = metric[1]
  points = points[1]
  curves = curves[1]
  bars = bars[1]
  xrug = xrug[1]
  yrug = yrug[1]
  theme = theme[1]
  palette = palette[1]
  plot_type = plot_type[1]
  # get grouping variables
  group_vars = GRgetGroupVars(fitData)
  # assertthat::assert_that(palette %in% c("default","npg", "aaas"), 
  #                         msg = "palette must be one of the following: 'default', 'npg', 'aaas'")
  # check that metric is allowed
  assertthat::assert_that(is.character(metric))
  assertthat::assert_that(metric %in% c("GR", "rel_cell"))
  # check that xrug and yrug are allowed
  xrug_options = c("none", "GR50", "GEC50", "IC50", "EC50")
  assertthat::assert_that(is.character(xrug))
  assertthat::assert_that(xrug %in% xrug_options, 
    msg = 'xrug must be one of the following: "none", "GR50", "GEC50", "IC50", "EC50"')
  
  yrug_options = c("none", "GRinf", "GRmax", "Einf", "Emax")
  assertthat::assert_that(is.character(yrug))
  assertthat::assert_that(yrug %in% yrug_options, 
    msg = 'yrug must be one of the following: "none", "GRinf", "GRmax", "Einf", "Emax"')
  # check to make sure the rug matches the metric... e.g. GR50 rug only for "GR" curve
  # xrug
  assertthat::assert_that(!(metric == "GR" && xrug %in% c("IC50", "EC50")),
                          msg = 'For metric "GR", xrug must be "GR50" or GEC50"')
  assertthat::assert_that(!(metric == "rel_cell" && xrug %in% c("GR50", "GEC50")),
                          msg = 'For metric "rel_cell", xrug must be "IC50" or "EC50"')
  # yrug
  assertthat::assert_that(!(metric == "GR" && yrug %in% c("Einf", "Emax")),
                          msg = 'For metric "GR", yrug must be "GRinf" or "GRmax"')
  assertthat::assert_that(!(metric == "rel_cell" && yrug %in% c("GRinf", "GRmax")),
                          msg = 'For metric "rel_cell", yrug must be "Einf" or "Emax"')
  # check that facets are allowed
  assertthat::assert_that(facet_row %in% c("none", group_vars))
  assertthat::assert_that(facet_col %in% c("none", group_vars))
  assertthat::assert_that(facet_col != facet_row | (facet_col == "none" && facet_row == "none"),
                          msg = "facet_col and facet_row must be different")
  assertthat::assert_that(metric != "IC", msg = 'For the traditional dose-response curve based on relative cell counts, please use metric = "rel_cell" instead of metric = "IC". This notation has been changed as of Version 1.3.2.')
  # data frame for points
  data = S4Vectors::metadata(fitData)[[1]]
  # data frame for metrics, to make curves and rugs
  parameterTable = GRgetMetrics(fitData) %>% as_tibble()
  if(length(group_vars) == 0) data$experiment = "All Data"
  # change experiment to character from factor if necessary
  data$experiment = as.character(data$experiment) 
  # filter to only selected experiments
  if(!identical(experiments, "all")) {
    parameterTable %<>% dplyr::filter(experiment %in% experiments)
    data %<>% dplyr::filter(experiment %in% experiments)
  }
  if(min == "auto") min = min(data$concentration, na.rm = TRUE)
  if(max == "auto") max = max(data$concentration, na.rm = TRUE)
  # define x support for curve
  len = (log10(max) - log10(min))*100
  concentration = 10^(seq(log10(min) - 1, log10(max) + 1, length.out = len))
  # define function for curve mapping
  .create_curve_data = function(EC50, Einf, h, fit_type, flat_fit, experiment, c) {
    df = data.frame(experiment = experiment, concentration = c, log10_concentration = log10(c))
    if(fit_type == "sigmoid") df$y_val = Einf + (1 - Einf)/(1 + (c/EC50)^h)
    if(fit_type == "flat") df$y_val = flat_fit
    #if(fit_type == "biphasic") df$y_val = NA ### make df for biphasic fit
    return(df)
  }
  # make list (tibble) of inputs for curve
  if(metric == "rel_cell") {
    curve_input_list = parameterTable %>% dplyr::select(EC50, Einf, h, fit_rel_cell, flat_fit_rel_cell, experiment) %>%
      dplyr::rename(fit_type = fit_rel_cell, flat_fit = flat_fit_rel_cell) %>% dplyr::as_tibble() %>%
      dplyr::mutate(c = list(concentration))
  } else if(metric == "GR") {
    curve_input_list = parameterTable %>% dplyr::select(GEC50, GRinf, h_GR, fit_GR, flat_fit_GR, experiment) %>%
      dplyr::rename(EC50 = GEC50, Einf = GRinf, h = h_GR, fit_type = fit_GR, flat_fit = flat_fit_GR) %>% 
      dplyr::as_tibble() %>% dplyr::mutate(c = list(concentration))
  }
  # make data frame for mapping "experiment" to grouping variables
  data_for_join = data %>% dplyr::select_at(c("experiment", group_vars))
  # data frame for curves to give to ggplot
  curve_data_all = suppressWarnings(purrr::pmap_dfr(.l = curve_input_list, .f = .create_curve_data)) %>%
    dplyr::left_join(data_for_join, by = "experiment")
  # data frame for (all) points
  if(metric == "GR") {
    data %<>% dplyr::select_at(c(group_vars, "concentration", "log10_concentration", 
                                   "GRvalue", "experiment")) %>%
      dplyr::rename(y_val = GRvalue)
  } else if(metric == "rel_cell") {
    data %<>% dplyr::select_at(c(group_vars, "concentration", "log10_concentration", 
                                     "rel_cell_count", "experiment")) %>%
      dplyr::rename(y_val = rel_cell_count)
  }
  # data frame for (average) points
  data_mean = data %>% dplyr::group_by_at(c(group_vars, "experiment", 
                                            "concentration", "log10_concentration")) %>%
    dplyr::summarise(y_val_mean = mean(y_val, na.rm = TRUE), 
                     y_val_sd = sd(y_val, na.rm = TRUE),
                     ynum = length(y_val)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(y_val_se = y_val_sd/sqrt(ynum))

  # round to 3 significant digits
  data %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3)) # points (all)
  data_mean %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3)) # points (average)
  parameterTable %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3)) # rugs
  curve_data_all %<>% dplyr::mutate_if(is.numeric, function(x) signif(x,3)) # curves
  
  # initialize plot
  p = ggplot2::ggplot()
  # add curves to the plot
  if(curves == "line") {
    p = p + ggplot2::geom_line(data = data_mean, ggplot2::aes(x = log10_concentration,
          y = y_val_mean, colour = experiment), size = 1.1)
          #### scale transformations don't work with plotly :(
          # scale_x_continuous(labels = trans_format("identity", math_format(10^.x)),limits = c(-3.5, 1.5)) +
          # annotation_logticks(sides = "b", short = unit(0.1, "cm"), mid = unit(0.2, "cm"),long = unit(0.3, "cm"))
  } else if(curves == "fit") {
    p = p + ggplot2::geom_line(data = curve_data_all,
          ggplot2::aes(x = log10_concentration, y = y_val, colour = experiment), size = 1.1)
  } else if(curves == "none") {
    # do nothing
  }
  # add points to the plot
  if(points == "average") {
    p = p + ggplot2::geom_point(data = data_mean, ggplot2::aes(x = log10_concentration,
      y = y_val_mean, colour = experiment), size = 2)
  } else if(points == "all") {
    p = p + ggplot2::geom_point(data = data, ggplot2::aes(x = log10_concentration,
          y = y_val, colour = experiment), size = 2)
  } else if(points == "none") {
    # do nothing
  }
  # add error bars to the plot
  bar_width = 0.2
  if(bars == "sd") {
    p = p + ggplot2::geom_errorbar(data = data_mean, ggplot2::aes(x = log10_concentration, 
              ymin = y_val_mean - y_val_sd, ymax = y_val_mean + y_val_sd, 
              colour = experiment), width = bar_width)
  } else if(bars == "se") {
    p = p + ggplot2::geom_errorbar(data = data_mean, ggplot2::aes(x = log10_concentration, 
               ymin = y_val_mean - y_val_se, ymax = y_val_mean + y_val_se, 
               colour = experiment), width = bar_width)
  }
  p = p + ggplot2::xlab('Concentration (log10 scale)')
  if(metric == "GR") {
    # set x and y range for plot, set labels, add horizontal lines
    p = p + ggplot2::coord_cartesian(xlim = c(log10(min)-0.1,
                                              log10(max)+0.1),
                                     ylim = c(-1, 1.5), expand = F) +
      ggplot2::ggtitle("Concentration vs. GR values") +
      ggplot2::ylab('GR value') +
      ggplot2::geom_hline(yintercept = 0, size = 1, colour = "#1F77B4")
      #ggplot2::geom_hline(yintercept = 1, size = 1, linetype = "dashed") +
      #ggplot2::geom_hline(yintercept = 0.5, size = 1, linetype = "dashed") +
      #ggplot2::geom_hline(yintercept = -1, size = 1, linetype = "dashed")
  } else if(metric == "rel_cell") {
    # set x and y range for plot, set labels, add horizontal lines
    p = p + ggplot2::coord_cartesian(xlim = c(log10(min)-0.1,
                                              log10(max)+0.1),
                                     ylim = c(0, 1.5), expand = F) +
      ggplot2::ggtitle("Concentration vs. Relative cell count") +
      ggplot2::ylab('Relative cell count')
  }
  ###  - Change code above so that curve parameters are called the same thing
  ### for GR and traditional curve. Then change rug names below to agree with this.
  ### - Maybe make an option for marginal plots of GR metrics instead of rugs.
  ### - Check how to change color scheme so that colors get used more than once
  ### instead of running out of colors
  
  # add rugs to plot
  rug_size = 1.1
  if(xrug != "none") p = p + ggplot2::geom_rug(data = parameterTable,
    ggplot2::aes_string(x = paste0("log10_", xrug), colour = "experiment"), size = rug_size)
  if(yrug != "none") p = p + ggplot2::geom_rug(data = parameterTable,
    ggplot2::aes_string(y = yrug, colour = "experiment"), size = rug_size)
  ### alternative way to do the rug... allows for length control (good), but xrug and yrug 
  ### can look like different lengths on the screen (bad)
  # rug_len = 0.25
  # if(xrug != "none") {
  #   p = p + ggplot2::geom_segment(data = parameterTable, 
  #     ggplot2::aes_string(x = paste0("log10_", xrug), xend = paste0("log10_", xrug),
  #                         y = p$coordinates$limits$y[1], yend = p$coordinates$limits$y[1] + rug_len,
  #                         colour = "experiment"), size = rug_size)
  # }
  # if(yrug != "none") {
  #   p = p + ggplot2::geom_segment(data = parameterTable, 
  #     ggplot2::aes_string(x = p$coordinates$limits$x[1], xend = p$coordinates$limits$x[1] + rug_len,
  #                         y = yrug, yend = yrug,
  #                         colour = "experiment"), size = rug_size)
  # }
  # add theme to plot
  p = p + ggplot2::theme_classic() #+ do.call(theme, args = list())
  # add palette to plot
  ###p = p + scale_colour_npg()
  # configure plot facets
  if(facet_row != "none" | facet_col != "none") {
    if(facet_row == "none") facet_row = "."
    if(facet_col == "none") facet_col = "."
    p = p + lemon::facet_rep_grid(stats::reformulate(facet_col,facet_row))
  }
  # return ggplot or plotly object
  if(plot_type == "interactive") {
    if(facet_row != ".") {
      # give extra x-axis space so that the legend doesn't overlap labels
      q = plotly::ggplotly(p) %>% plotly::layout(legend = list(x = 1.05))
    } else {
      q = plotly::ggplotly(p)
    }
    return(q)
  } else {
    return(p)
  }
}
